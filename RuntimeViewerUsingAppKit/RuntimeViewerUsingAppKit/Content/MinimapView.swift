import AppKit

// MARK: -

// MARK: Minimap view for macOS

/// Customised text view for the minimap.
///
class MinimapView: NSTextView {
    // Highlight the current line.
    //
    override func drawBackground(in rect: NSRect) {
        let rectWithinBounds = rect.intersection(bounds)
        super.drawBackground(in: rectWithinBounds)

        guard let textLayoutManager = textLayoutManager,
              let textContentStorage = textContentStorage
        else { return }

        let viewportRange = textLayoutManager.textViewportLayoutController.viewportRange

        // If the selection is an insertion point, highlight the corresponding line
        if let location = insertionPoint,
           let textLocation = textContentStorage.textLocation(for: location) {
            if viewportRange == nil
                || viewportRange!.contains(textLocation)
                || viewportRange!.endLocation.compare(textLocation) == .orderedSame {
                drawBackgroundHighlight(
                    within: rectWithinBounds,
                    forLineContaining: textLocation,
                    withColour: .textBackgroundColor
                )
            }
        }
    }
}

extension NSFont {
    /// The constant adavance for a (horizontal) monospace font.
    ///
    var maximumHorizontalAdvancement: CGFloat { maximumAdvancement.width }

    /// The line height (which is an exting property on `UIFont`).
    ///
    var lineHeight: CGFloat { ceil(ascender - descender - leading) }
}

// MARK: -

// MARK: Minimap layout functionality

class MinimapLineFragment: NSTextLineFragment {
    /// Text line fragment that we base our derived fragment on.
    ///
    /// `NSTextLineFragment` is a class cluster; hence, we need to embded a fragment generated by TextKit for us to get
    /// at its properties.
    ///
    private let textLineFragment: NSTextLineFragment

    /// All rendering attribute runs applying to this line.
    ///
    private let attributes: [MinimapLayoutFragment.AttributeRun]

    /// The advacement per glyph (for a monospaced font).
    ///
    private let advancement: CGFloat

    init(_ textLineFragment: NSTextLineFragment, attributes: [MinimapLayoutFragment.AttributeRun]) {
        self.textLineFragment = textLineFragment
        self.attributes = attributes

        let attributedString = textLineFragment.attributedString,
            range = textLineFragment.characterRange

        // Determine the advancement per glyph (assuming a monospaced font), scaling it down for the minimap.
        let font = if range.length > 0,
                      let font = attributedString.attribute(.font, at: range.location, effectiveRange: nil) as? NSFont { font }
        else { NSFont.monospacedSystemFont(ofSize: NSFont.systemFontSize, weight: .regular) }
        self.advancement = font.maximumHorizontalAdvancement / minimapRatio

        super.init(attributedString: attributedString, range: range)
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    override var glyphOrigin: CGPoint { CGPoint(
        x: textLineFragment.glyphOrigin.x / minimapRatio,
        y: textLineFragment.glyphOrigin.y / minimapRatio
    ) }

    override var typographicBounds: CGRect {
        CGRect(
            x: textLineFragment.typographicBounds.minX / minimapRatio,
            y: textLineFragment.typographicBounds.minY / minimapRatio,
            width: textLineFragment.typographicBounds.width / minimapRatio,
            height: textLineFragment.typographicBounds.height / minimapRatio
        )
    }

    override func characterIndex(for point: CGPoint) -> Int {
        textLineFragment.characterIndex(for: CGPoint(x: point.x * minimapRatio, y: point.y * minimapRatio))
    }

    override func fractionOfDistanceThroughGlyph(for point: CGPoint) -> CGFloat {
        textLineFragment.fractionOfDistanceThroughGlyph(for: point)
    }

    override func locationForCharacter(at index: Int) -> CGPoint {
        let point = textLineFragment.locationForCharacter(at: index)
        return CGPoint(x: point.x / minimapRatio, y: point.y / minimapRatio)
    }

    // Draw boxes using a character's foreground colour instead of actual glyphs.
    override func draw(at point: CGPoint, in context: CGContext) {
        // Leave some space between glyph boxes on adjacent lines
        let gap = typographicBounds.height * 0.3

        for attribute in attributes {
            let attributeRect = CGRect(
                x: floor(point.x + advancement * CGFloat(attribute.range.location)),
                y: floor(point.y + gap / 2),
                width: floor(advancement * CGFloat(attribute.range.length)),
                height: typographicBounds.height - gap
            )
            if let colour = attribute.attributes[.foregroundColor] as? NSColor {
                colour.withAlphaComponent(0.50).setFill()
            }
            NSBezierPath(rect: attributeRect).fill()
        }
    }
}

/// Minimap layout fragments replaces all line fragments by a our own variant of minimap line fragments, which draw
/// coloured boxes instead of actual glyphs.
///
class MinimapLayoutFragment: NSTextLayoutFragment {
    private var _textLineFragments: [NSTextLineFragment] = []

    private var observation: NSKeyValueObservation?

    override var layoutFragmentFrame: CGRect {
        CGRect(
            x: super.layoutFragmentFrame.minX,
            y: super.layoutFragmentFrame.minY,
            width: super.layoutFragmentFrame.width / minimapRatio,
            height: super.layoutFragmentFrame.height / minimapRatio
        )
    }

    // NB: We don't override `renderingSurfaceBounds` as that is calculated on the basis of `layoutFragmentFrame`.

    @objc override dynamic var textLineFragments: [NSTextLineFragment] {
        return _textLineFragments
    }

    override init(textElement: NSTextElement, range rangeInElement: NSTextRange?) {
        super.init(textElement: textElement, range: rangeInElement)
        self.observation = super.observe(\.textLineFragments, options: [.new]) { [weak self] _, _ in

            // NB: We cannot use `change.newValue` as this seems to pull the value from the subclass property (which we
            //     want to update here). Instead, we need to directly access `super`. This is, however as per Swift 5.9
            //     not possible in a closure weakly capturing `self` (which we need to do here to avoid a retain cycle).
            //     Hence, we defer to an auxilliary method.
            self?.updateTextLineFragments()
        }
    }

    typealias AttributeRun = (attributes: [NSAttributedString.Key: Any], range: NSRange)

    // We don't draw white space and control characters
    private let invisibleCharacterers = CharacterSet.whitespacesAndNewlines.union(CharacterSet.controlCharacters)
    private lazy var invertedInvisibleCharacters = invisibleCharacterers.inverted

    /// Update the text line fragments from the corresponding property of `super`.
    ///
    private func updateTextLineFragments() {
        if let textLayoutManager = textLayoutManager {
            var location = rangeInElement.location
            _textLineFragments = []
            for fragment in super.textLineFragments {
                guard let string = (fragment.attributedString.string[fragment.characterRange].flatMap { String($0) })
                else { break }

                let attributeRuns
                    = if let endLocation = textLayoutManager.location(location, offsetBy: fragment.characterRange.length),
                    let textRange = NSTextRange(location: location, end: endLocation) {
                    textLayoutManager.renderingAttributes(in: textRange).map { attributeRun in
                        (
                            attributes: attributeRun.attributes,
                            range: NSRange(
                                location: textLayoutManager.offset(from: location, to: attributeRun.textRange.location),
                                length: textLayoutManager.offset(from: attributeRun.textRange.location, to: attributeRun.textRange.endLocation)
                            )
                        )
                    }
                } else { [AttributeRun]() }

                var attributeRunsWithoutWhitespace: [AttributeRun] = []
                for (attributes, range) in attributeRuns {
                    if attributes[.hideInvisibles] == nil {
                        attributeRunsWithoutWhitespace.append((attributes: attributes, range: range))
                    } else {
                        var remainingRange = range
                        while remainingRange.length > 0,
                              let match = string.rangeOfCharacter(from: invisibleCharacterers, range: remainingRange.range(in: string)) {
                            let lower = match.lowerBound.utf16Offset(in: string),
                                upper = min(match.upperBound.utf16Offset(in: string), remainingRange.max)

                            // If we have got a prefix with visible characters, emit an attribute run covering those.
                            if lower > remainingRange.location {
                                attributeRunsWithoutWhitespace.append((
                                    attributes: attributes,
                                    range: NSRange(
                                        location: remainingRange.location,
                                        length: lower - remainingRange.location
                                    )
                                ))
                            }

                            // Advance the remaining range to after the character found in `match`.
                            remainingRange = NSRange(
                                location: upper,
                                length: remainingRange.length - (upper - remainingRange.location)
                            )

                            if let nextVisibleCharacter = string.rangeOfCharacter(
                                from: invertedInvisibleCharacters,
                                range: remainingRange.range(in: string)
                            ) {
                                // If there is another visible character, the new remaining range starts with that character.
                                let lower = nextVisibleCharacter.lowerBound.utf16Offset(in: string)
                                remainingRange = NSRange(
                                    location: lower,
                                    length: remainingRange.length - (lower - remainingRange.location)
                                )

                            } else { // If there are no more visible characters, we are done.
                                remainingRange.length = 0
                            }
                        }
                    }
                }
                _textLineFragments.append(MinimapLineFragment(fragment, attributes: attributeRunsWithoutWhitespace))
                location = textLayoutManager.location(location, offsetBy: fragment.characterRange.length) ?? location
            }
        }
    }

    @available(*, unavailable)
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

class MinimapTextLayoutManagerDelegate: NSObject, NSTextLayoutManagerDelegate {
    // We create instances of our own flavour of layout fragments
    func textLayoutManager(_ textLayoutManager: NSTextLayoutManager,
                           textLayoutFragmentFor location: NSTextLocation,
                           in textElement: NSTextElement)
        -> NSTextLayoutFragment {
        guard let paragraph = textElement as? NSTextParagraph
        else { return NSTextLayoutFragment(textElement: textElement, range: nil) }

        return MinimapLayoutFragment(textElement: paragraph, range: nil)
    }
}

let minimapRatio = CGFloat(8)

extension NSAttributedString.Key {
    /// Attribute to indicate that an attribute run has the default styling and not a token-specific styling.
    ///
    static let hideInvisibles: NSAttributedString.Key = .init("hideInvisibles")
}

extension NSTextView {
    typealias Color = NSColor
    typealias Font = NSFont

    var optTextLayoutManager: NSTextLayoutManager? { textLayoutManager }
    var optTextContainer: NSTextContainer? { textContainer }
    var optTextContentStorage: NSTextContentStorage? { textContentStorage }

    var textBackgroundColor: Color? { backgroundColor }
    var textFont: Font? { font }
    var textContainerOrigin: CGPoint { return CGPoint(x: textContainerInset.width, y: textContainerInset.height) }

    var text: String! {
        get { string }
        set { string = newValue }
    }

    var insertionPoint: Int? {
        if let selection = selectedRanges.first as? NSRange, selection.length == 0 { return selection.location }
        else { return nil }
    }

    var documentVisibleRect: CGRect { enclosingScrollView?.documentVisibleRect ?? bounds }

    var contentSize: CGSize { bounds.size }

    func drawBackgroundHighlight(within rect: CGRect,
                                 forLineContaining textLocation: NSTextLocation,
                                 withColour colour: NSColor) {
        guard let textLayoutManager = optTextLayoutManager else { return }

        colour.setFill()
        if let fragmentFrame = textLayoutManager.textLayoutFragment(for: textLocation)?.layoutFragmentFrameWithoutExtraLineFragment,
           let highlightRect = lineBackgroundRect(y: fragmentFrame.minY, height: fragmentFrame.height) {
            let clippedRect = highlightRect.intersection(rect)
            if !clippedRect.isNull { NSBezierPath(rect: clippedRect).fill() }

        } else
        if let previousLocation = optTextContentStorage?.location(textLocation, offsetBy: -1),
           let fragmentFrame = textLayoutManager.textLayoutFragment(for: previousLocation)?.layoutFragmentFrameExtraLineFragment,
           let highlightRect = lineBackgroundRect(y: fragmentFrame.minY, height: fragmentFrame.height) {
            let clippedRect = highlightRect.intersection(rect)
            if !clippedRect.isNull { NSBezierPath(rect: clippedRect).fill() }
        }
    }

    func lineBackgroundRect(y: CGFloat, height: CGFloat) -> CGRect? {
        // We start at x = 0 as it looks nicer in case we overscoll when horizontal scrolling is enabled (i.e., when lines
        // are not wrapped).
        return CGRect(x: 0, y: y, width: bounds.size.width, height: height)
    }
}
